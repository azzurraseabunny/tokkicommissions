<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Infinite Dino-Style Eye Game</title>
<style>
  body { margin:0; overflow:hidden; background:#222; font-family:sans-serif; }
  canvas { display:block; }
  #hud { position:absolute; top:10px; left:10px; font-size:18px; color:white; }
  #instructions {
    position:absolute;
    top:50px;
    left:10px;
    font-size:16px;
    color:white;
    background: rgba(0,0,0,0.5);
    padding:8px;
    border-radius:5px;
    max-width:250px;
    line-height:1.4;
  }
</style>
</head>
<body>
<div id="hud"></div>
<div id="instructions">
  <b>Controls:</b><br>
  Move: Arrow keys / WASD<br>
  Jump: Up / W / Space<br>
  Sprint: Down / S<br>
  Parry: Shift
</div>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const gravity = 0.5;

// Audio
const bgMusic = new Audio('spammail/ratmode.mp3');
bgMusic.loop = true;
bgMusic.volume = 0.5;
document.addEventListener('click', ()=>bgMusic.play());

// Parry sounds
const parryReadySound = new Audio('spammail/pew.mp3');  // can parry sound
parryReadySound.volume = 0.05; // very low
const parrySuccessSound = new Audio('spammail/bewn.mp3'); // successful parry

// Player
const player = {x:100,y:canvas.height-150,width:30,height:50,dx:0,dy:0,speed:5,jumpPower:12,onGround:true,facing:1,parryCooldown:0};

// Camera
let cameraX = 0;

// Platforms
let platforms = [];
let lastPlatformX = 0;
const platformHeight = 50;

// Obstacles
let obstacles = [];
let lastObstacleX = 500;

// Flying hazards
let flyingParticles = [];

// Background pillars
let bgPillars = [];
let lastPillarX = 0;
const pillarColors = [100,120,140,160,180,200,220,240,180,160];

// Chaser
let chaser = {x:200, y:-100, active:false};
let chaserTimer = 0;
const chaserBaseSpeed = 9;
const parryRange = 120;
const parryCooldownFrames = 60;
let chaserVulnerable = false;
let vulnerabilityTimer = 0;

// Player position delay
let playerPositions = [];
const delayFrames = 15;

// Particles
let particles = [];

// HUD
const hud = document.getElementById('hud');

function randomGray(){ return Math.floor(Math.random()*156+100); }

function generatePlatforms(){
  while(lastPlatformX < player.x + canvas.width*2){
    const width = 200 + Math.random()*200;
    platforms.push({x:lastPlatformX, y:canvas.height-platformHeight, width, height:platformHeight});
    lastPlatformX += width;
  }
}

function generateObstacles(){
  while(lastObstacleX < player.x + canvas.width*2){
    if(Math.random()<0.25){ 
      const width = 20 + Math.random()*30;
      const height = 30 + Math.random()*60;
      const y = canvas.height-50-height;
      obstacles.push({x:lastObstacleX,y,width,height,color:'orange'});
    }
    lastObstacleX += 300 + Math.random()*300; 
  }
}

function generatePillars(){
  while(lastPillarX < player.x + canvas.width*2){
    const width = 50 + Math.random()*150;
    const height = 300 + Math.random()*500;
    const brightness = pillarColors[Math.floor(Math.random()*pillarColors.length)];
    bgPillars.push({x:lastPillarX,y:canvas.height-50-height,width,height,scrollFactor:0.2+Math.random()*0.5,rotation:(Math.random()-0.5)*Math.PI/12,color:`rgb(${brightness},${brightness},${brightness})`});
    lastPillarX += 100 + Math.random()*200;
  }
}

// Controls
const keys = {};
document.addEventListener('keydown', e => keys[e.key] = true);
document.addEventListener('keyup', e => keys[e.key] = false);

function update(){
  // Player movement
  player.dx = 0;
  let moveSpeed = player.speed;
  if(keys['ArrowDown'] || keys['s']) moveSpeed *= 2;
  if(keys['ArrowLeft'] || keys['a']) {player.dx = -moveSpeed; player.facing=-1;}
  if(keys['ArrowRight'] || keys['d']) {player.dx = moveSpeed; player.facing=1;}
  player.x += player.dx;

  if((keys['ArrowUp'] || keys['w'] || keys[' ']) && player.onGround){
    player.dy = -player.jumpPower; player.onGround = false;
  }
  player.dy += gravity;
  player.y += player.dy;

  // Platform collision
  player.onGround = false;
  platforms.forEach(p=>{
    if(player.x+player.width>p.x && player.x<p.x+p.width &&
       player.y+player.height>p.y && player.y+player.height<p.y+p.height+player.dy+1){
      if(player.dy>=0){ player.y = p.y - player.height; player.dy=0; player.onGround = true; }
    }
  });

  // Obstacle collision
  obstacles.forEach(o=>{
    if(player.x+player.width>o.x && player.x<o.x+o.width &&
       player.y+player.height>o.y && player.y<o.y+o.height){
      window.close(); alert("Hit an obstacle!");
    }
  });

  // Generate new content
  generatePlatforms();
  generateObstacles();
  generatePillars();

  // Camera
  cameraX = player.x - canvas.width/2 + player.width/2;

  // Flying hazards
  if(Math.random()<0.015){
    const spawnY = Math.random()*(canvas.height-300);
    flyingParticles.push({x:player.x+canvas.width+50,y:spawnY,dx:-5,dy:0});
  }

  flyingParticles.forEach(p=>{
    p.x += p.dx; p.y += p.dy;
    if(Math.random()<0.5){
      particles.push({x:p.x,y:p.y,dx:(Math.random()-0.5)*2,dy:(Math.random()-0.5)*2,life:30+Math.random()*20,size:10+Math.random()*10});
    }
    if(player.x+player.width>p.x && player.x<p.x+10 && player.y+player.height>p.y && player.y<p.y+10){
      window.close(); alert("Hit a flying hazard!");
    }
  });
  flyingParticles = flyingParticles.filter(p=>p.x+cameraX > player.x-100);

  // Record player positions
  playerPositions.push({x:player.x,y:player.y});
  if(playerPositions.length>delayFrames) playerPositions.shift();

  // Chaser logic
  if(chaser){
    chaserTimer += 1/60;
    if(!chaser.active){
      chaser.y += 1 + Math.sin(chaserTimer*2)*0.5;
      for(let i=0;i<8;i++){
        particles.push({
          x: chaser.x + (Math.random()-0.5)*30,
          y: chaser.y + (Math.random()-0.5)*20,
          dx: (Math.random()-0.5)*2,
          dy: (Math.random()-0.5)*2,
          life:30 + Math.random()*20,
          size:15 + Math.random()*10
        });
      }
      if(chaserTimer >= 5.2){
        chaser.active = true;
        chaserTimer = 0;
      }
    } else {
      const target = playerPositions[0]||{x:player.x,y:player.y};
      let dx = target.x - chaser.x;
      let dy = target.y - chaser.y;
      let dist = Math.sqrt(dx*dx + dy*dy);
      let speed = Math.max(player.speed+1, chaserBaseSpeed + Math.min(10, dist/50));

      // Continuous low-volume "can parry" sound if in range and not vulnerable
      if(dist <= parryRange && !chaserVulnerable && player.parryCooldown<=0){
        parryReadySound.play();
      }

      if(!chaserVulnerable && dist>1){
        chaser.x += (dx/dist)*speed;
        chaser.y += (dy/dist)*speed;
      }
      if(!chaserVulnerable && dist < player.width/2+30){
        window.close(); alert("Caught!");
      }

      // Successful parry
      if(dist <= parryRange && keys['Shift'] && player.parryCooldown<=0){
        player.dy = -25; 
        player.dx = -player.facing*10;
        player.parryCooldown = parryCooldownFrames;
        chaserVulnerable = true;
        vulnerabilityTimer = 180;
        parrySuccessSound.play();
      }

      if(chaserVulnerable){ vulnerabilityTimer--; if(vulnerabilityTimer<=0) chaserVulnerable=false; }

      for(let i=0;i<5;i++){
        particles.push({
          x: chaser.x,
          y: chaser.y,
          dx:(Math.random()-0.5)*4,
          dy:(Math.random()-0.5)*4,
          life:30+Math.random()*20,
          size:20+Math.random()*15
        });
      }

      hud.innerHTML = `Distance to chaser: ${Math.round(dist)} px`;
    }
  }

  particles.forEach(p=>{p.x+=p.dx; p.y+=p.dy; p.size*=0.97; p.life--;});
  particles = particles.filter(p=>p.life>0);

  if(player.parryCooldown>0) player.parryCooldown--;
}

function draw(){
  let gradient = ctx.createLinearGradient(0,0,0,canvas.height);
  gradient.addColorStop(0,'#555'); gradient.addColorStop(1,'#111');
  ctx.fillStyle = gradient; ctx.fillRect(0,0,canvas.width,canvas.height);

  bgPillars.forEach(p=>{
    ctx.save(); ctx.translate(p.x-cameraX*p.scrollFactor+p.width/2,p.y+p.height/2);
    ctx.rotate(p.rotation); ctx.fillStyle=p.color; ctx.fillRect(-p.width/2,-p.height/2,p.width,p.height); ctx.restore();
  });

  ctx.fillStyle='gray'; platforms.forEach(p=>ctx.fillRect(p.x-cameraX,p.y,p.width,p.height));
  obstacles.forEach(o=>{ctx.fillStyle=o.color; ctx.fillRect(o.x-cameraX,o.y,o.width,o.height);});

  particles.forEach(p=>{ctx.strokeStyle='red';ctx.lineWidth=5;ctx.beginPath();ctx.arc(p.x-cameraX,p.y,p.size,0,Math.PI*2);ctx.stroke();});
  particles.forEach(p=>{ctx.fillStyle='black';ctx.beginPath();ctx.arc(p.x-cameraX,p.y,p.size,0,Math.PI*2);ctx.fill();});

  ctx.fillStyle='lightgray'; ctx.fillRect(player.x-cameraX,player.y,player.width,player.height);

  if(chaser){
    ctx.fillStyle = chaserVulnerable ? 'green' : 'black';
    ctx.beginPath();
    ctx.ellipse(chaser.x - cameraX, chaser.y, 50, 35, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 4;
    ctx.stroke();

    ctx.strokeStyle='white'; ctx.lineWidth=3;
    ctx.beginPath();
    ctx.moveTo(chaser.x-15-cameraX, chaser.y-15);
    ctx.lineTo(chaser.x+15-cameraX, chaser.y+15);
    ctx.moveTo(chaser.x+15-cameraX, chaser.y-15);
    ctx.lineTo(chaser.x-15-cameraX, chaser.y+15);
    ctx.stroke();

    const centerX = canvas.width/2, centerY = 50;
    const arrowAngle = Math.atan2(chaser.y-player.y, chaser.x-player.x);
    ctx.save(); ctx.translate(centerX,centerY); ctx.rotate(arrowAngle);
    ctx.fillStyle='pink';
    ctx.beginPath();
    ctx.moveTo(0,-10); ctx.lineTo(20,10); ctx.lineTo(-20,10); ctx.closePath(); ctx.fill();
    ctx.restore();
  }
}

function gameLoop(){ update(); draw(); requestAnimationFrame(gameLoop); }
gameLoop();
</script>
</body>
</html>
